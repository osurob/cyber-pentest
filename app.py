from flask import Flask, render_template, request, redirect, url_for, send_from_directory, make_response
from flask_wtf.csrf import CSRFProtect
import sqlite3
import re
import bcrypt
import datetime
import requests
import hashlib

app = Flask(__name__)


#key is the IP address
    #values [ failed attempts, blocked until ]
ip_addresses_dict = {}

# Globally enable CSRF protection within the app
# Code borrowed from: https://dev.to/dev0928/how-to-enable-csrf-protection-in-the-python-flask-app-5age
csrf = CSRFProtect(app)

# Hookup stylesheet
@app.route('/style.css')
def style():
    return send_from_directory('templates', 'style.css')


# Password checker to ensure we have requirements
def password_check(password):
    if len(password) < 8:
        return False
    elif not re.search("[a-zA-Z]", password):
        return False
    elif not re.search("[A-Z]", password):
        return False
    else:
        return True

def is_password_breached(password):
    sha1hash = hashlib.sha1(password.encode('utf-8')).hexdigest().upper()
    prefix = sha1hash[:5]
    suffix = sha1hash[5:]
    response = requests.get(f"https://api.pwnedpasswords.com/range/{prefix}")
    if response.status_code != 200:
        raise RuntimeError("Error fetching breached passwords")
    for line in response.text.splitlines():
        line_prefix, count = line.split(":")
        if line_prefix == suffix:
            return int(count)
    return 0

#Creates user database
def create_database():
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute('DROP TABLE IF EXISTS users')
    c.execute('''
        CREATE TABLE users (
            id INTEGER PRIMARY KEY,
            username TEXT NOT NULL,
            password TEXT NOT NULL,
            salt TEXT NOT NULL
        )
    ''')
    conn.commit()
    conn.close()

# Function to check if an IP address is currently blocked
def is_blocked(ip_address):
    if ip_addresses_dict[ip_address]:
        blocked_until = ip_addresses_dict[ip_address][1]

    #if blocked_until and blocked_until[0]:
    if ip_addresses_dict[ip_address] and blocked_until:
        # Remove any remaining microseconds from the timestamp
        blocked_until = blocked_until.replace(microsecond=0)
        if datetime.datetime.now() < datetime.datetime.strptime( str(blocked_until), '%Y-%m-%d %H:%M:%S'):
            return True
        else:
            ip_addresses_dict[ip_address] = [1, None]       # return to default val of unknown IP addr.
                                                            # but include this failed attempt
    return False

# Function to update the failed log-in attempts for an IP address
def update_failed_attempts(ip_address):
    blocked_until = None

    # Check if the IP address is already blocked
    if is_blocked(ip_address):
        return False

    # Increment the failed log-in attempts
    if ip_addresses_dict[ip_address][0]:
        ip_addresses_dict[ip_address][0] += 1
        if ip_addresses_dict[ip_address][0] >= 3:
            # Block the IP address for 1 minutes
            ip_addresses_dict[ip_address][1] = datetime.datetime.now() + datetime.timedelta(minutes=1)
    else:
        ip_addresses_dict[ip_address][0] = 1

    return True

def add_user(username, password):
    # Generate a random salt
    salt = bcrypt.gensalt()

    # Hash the password with the salt
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)

    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute("INSERT INTO users (username, password, salt) VALUES (?,?,?)", (username, hashed_password, salt))
    #c.execute("SELECT * FROM users WHERE username='" + username + "' AND password='" + password + "'")
    ## The above statement is more prone to SQL injection because it can allow for SQL queries through concat.
    ### The addition of the salt allows for

    conn.commit()
    conn.close()

def get_user(username, password):
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute("SELECT * FROM users WHERE username=?", (username,))
    user = c.fetchone()
    conn.close()

    # Check if user exists and verify password
    if user and bcrypt.checkpw(password.encode('utf-8'), user[2]):
        return user
    else:
        return None

@app.route('/')
def index():
    response = make_response(render_template("index.html"))
    return response

@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")


        # Check if the provided password has been breached
        count = is_password_breached(password)
        if count > 0:
            error_message = "Your password has been breached and appears in " \
                            f"{count} data breaches. Please choose a different password."
            return render_template('signup.html', error=error_message)

        #Data not breached,
        if password_check(password):
            add_user(username, password)
            return redirect("/")
        else:
            return render_template("signup.html", error="Password must be at least 8 characters, include 1 letter, and 1 uppercase letter.")
    return render_template("signup.html")

# Login route
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        ip_address = request.remote_addr  # Get the user's IP address from the request object
        
        if not ( ip_address in ip_addresses_dict.keys() ):          # add IP address to dict if it doesn't exist there
            ip_addresses_dict[ip_address] = [0, None]

        # Check if the IP address is blocked
        if is_blocked(ip_address):
            error = "Too many failed log-in attempts. This IP address has been temporarily blocked."
            return render_template('login.html', error=error)

        user = get_user(username, password)

        if user:
            # Reset the failed log-in attempts for this IP address
            ip_addresses_dict[ip_address] = [0, None]

            return redirect(url_for('user', username=username))
        else:
            # Increment the failed log-in attempts for this IP address
            update_failed_attempts(ip_address)
            error = "Invalid username or password. Please try again."

            # Set countdown timer of 5 seconds to prevent against brute-force attacks
            return render_template('login.html', error=error, countdown=5)

    return render_template('login.html')

@app.route('/user/<username>')

def user(username):
    return f'Hello, {username}!'

if __name__ == '__main__':
    create_database()
    app.run(debug=True)
